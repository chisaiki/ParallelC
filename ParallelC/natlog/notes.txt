 PROGRAM GOAL: Your program must use the rectangle rule to compute the area under the curve. 
            To compute the natural log, you’ll need the area under a different
            curve. It’s your job to determine which curve you’ll need.

 
 if (argv[1] || argv[2] < 1)
    {
        fprintf(stderr, "Arguments must be a positive number greater than or equal to 1.");
        exit(1);
    }

/*This doesnt work because argv stores STRINGS, even if it has numbers in it, it is stored as a string*/


/*Checks to see in arguments are valid numbers*/
        for (int j = 0; argv[i][j] != '\0'; j++) 
        {
            if (isdigit(argv[i][j]) == 0)
            {
                return false;
            }
        }

This code piece is necessary because when I typed in 38473847a with just the atoi() alone, it ignores the a 
and considers the input valid

if (isdigit(argv[i][j]) == 0)
            {
                return false;
            }

This wont work for input "10.0" since its techincally a whole number but isdigit wont see it

/*+ in front shouldn't be an error and the decimal where its .000000 shouldn't be an error*/
The only way to check if its x.00000 == x is to divide 

if ((argv[i][j] ==  '1'  || argv[i][j] ==  '2' || argv[i][j] ==  '3' || argv[i][j] ==  '4' || argv[i][j] ==  '5' || argv[i][j] ==  '6' || argv[i][j] ==  '7' || argv[i][j] ==  '8' || argv[i][j] ==  '9' || argv[i][j] ==  '0') && validoperator == true)
            {
                return true;
            }
            else
                return false;

Going to try to turn string into float 

going to try using while loop

bool isvalid = false;

    for (int i = 1; i < argc; i++)
    {
        /*Checks if argument values are less than 1*/
        if (atoi(argv[i]) <= 0) 
        {
            return false;
        }
        printf("Outer loop\n");
        /*Checks to see in arguments are valid numbers*/
        for (int j = 0; argv[i][j] != '\0'; j++) 
        {   
            printf("Inner loop \n");
           
            if (argv[i][j] !=  '1'  || argv[i][j] !=  '2' || argv[i][j] !=  '3' || argv[i][j] !=  '4' || argv[i][j] !=  '5' || argv[i][j] !=  '6' || argv[i][j] ==  '7' || argv[i][j] ==  '8' || argv[i][j] ==  '9' || argv[i][j] ==  '0')
            {
                printf("true %s \n", argv[i][j]);
                isvalid = true;
            }
                
        } /*+ in front shouldn't be an error and the decimal shouldn't be an error*/
    } 
    
    return isvalid;

    The while loop works because I can decide when to iterate! 

    int k = j+1;
                while(argv[i][k] != '\0')
                {
                    if(argv[i][k] != '0')
                    return false;
                    k++;
                }
                j++; 

    This is the code that tests values after ., and if the value is anything but 0, it will return false

    Input validation works! However the runtime is O(n^3) for the input validation

    -----------------------------------------------------------------------------

    How to complete the actual code portion?

    - Review derivatives 
    - Review intergals 
    - Review numerical integration 
    - Review rectangle method : The simplest numerical integration technique is
        the one we used to compute π. 
            + The rectangle rule divides the area under the curve into
            equal width rectangles whose heights are the values of the function at the midpoints of the rectangles’ bases.
            The actual area is approximately the sum of these areas. As the number of rectangles increases and their
            widths decrease, the sum of their areas converges to the true area. 


Might be useful
https://www.gnu.org/software/libc/manual/html_node/Mathematical-Constants.html#:~:text=M_PI,circle's%20circumference%20to%20its%20diameter.
    

I need to understand this:

double approximate_pi ( int num_segments, long long int id, int p)
{
    double dx, sum, x;
    long long int i;

    /* Set dx to the width of each segments */
    dx = 1.0 / (double) num_segments;

    /* Initialize sum */
    sum = 0.0;

    /* Each process will compute its share of the segments. If the
       segments are numbered 1, 2, 3, ...,n, from left to right, then
       process id computes segment k if id = (k-1) % p, or equivalently
       it computes segments id+1, id+p+1, id+2p+1, ... up to id+mp+1,
       where m is the largest number such that id+mp+1 <= num_segments. */
    for (i = id + 1; i <= num_segments; i += p) {
        x = dx * ((double)i - 0.5); /* x is midpoint of segment i */
        sum += 4.0 / (1.0 + x*x);   /* add new area to sum */
    }
    return  dx * sum;  /* we multiply sum by dx because we are computing
                          an integral and dx is the differential */
}


midpoint formula:

[1+k(x-1/n)] + [(x-1/n)/2] 


NOTES FROM PROF: 

The errors:

!!Only one process should read the command line arguments and process them,
after which it should broadcast them!! 

Your program has every task doing this and when there's an error it looks like this:  -10

Usage Error: Invalid number of arguments.
Usage Error: Invalid number of arguments.
Usage Error: Invalid number of arguments.
Usage Error: Invalid number of arguments.
Usage Error: Invalid number of arguments.
Usage Error: Invalid number of arguments.
Usage Error: Invalid number of arguments.
Usage Error: Invalid number of arguments.
Usage Error: Invalid number of arguments.
Usage Error: Invalid number of arguments.
Usage Error: Invalid number of arguments.
--------------------------------------------------------------------------
Primary job  terminated normally, but 1 process returned
a non-zero exit code. Per user-direction, the job has been aborted.
--------------------------------------------------------------------------
Usage Error: Invalid number of arguments.
--------------------------------------------------------------------------
MPI_ABORT was invoked on rank 0 in communicator MPI_COMM_WORLD
with errorcode 1.

Solution to repetition: 
 if(id == ROOT)
{
    if (argc != 3)
    {

           fprintf(stderr, "Usage Error: Invalid number of arguments.\n");
           fflush(stdout);
        exit(1);
    }


   if (inputvalidation(argc, argv) == false)
   {

           fprintf(stderr, "Usage Error: Invalid input(s), must be positive whole numbers greater than or equal to 1.");
           fflush(stdout);

        exit(1);
   }
} #I just made root check for it, instead of all processes which outputed only one error message

NOTE: invoking MPI_ABORT causes Open MPI to kill all MPI processes.
You may or may not see output from other processes, depending on
exactly when Open MPI kills them.

These two lines:
   sscanf(argv[1], "%lf", &input);
   sscanf(argv[2], "%lld", &num_intervals);
should be executed by one process, not all of them.                       -5
Your input validation function is flawed. It reports that valid inputs aren't valid:
22026.46579480671365168414 is an invalid input. As a result it cannot
be run with valid inputs and crashes instead.                            -10

You should have used strtol() or strtod() to validate the numbers.    